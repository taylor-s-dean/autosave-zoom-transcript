#!/usr/bin/env python3
import argparse
import json
import shutil
import subprocess
import sys
import time

# We use __PLACEHOLDERS__ and .replace() to keep JXA braces untouched.
JXA_TEMPLATE = r"""// Generated by autoclick.py – Zoom 'Save transcript' clicker (JXA)
function dbg(m){ if (__DEBUG__) console.log('[DBG] ' + m); }

(function main(){
  var DEBUG      = __DEBUG__;
  var PANE       = __PANE__;        // e.g. "Transcript"
  var NEEDLE     = __NEEDLE__;      // e.g. "save transcript"
  var CANDIDATES = __CANDIDATES__;  // e.g. ["zoom.us","Zoom Workplace"]
  var DO_ACT     = __DO_ACT__;      // bring app to front? (focus hop)

  var se = Application('System Events'); se.includeStandardAdditions = true;

  // 0) pick Zoom process
  var zoom = null;
  for (var i=0;i<CANDIDATES.length;i++){
    try { if (se.processes.byName(CANDIDATES[i]).exists()) { zoom = CANDIDATES[i]; break; } } catch(e){}
  }
  if (!zoom){ dbg('NO_PROCESS'); return 'NO_PROCESS'; }
  dbg('zoomName=' + zoom);

  // 1) optionally activate to hydrate AX tree
  if (DO_ACT) { Application(zoom).activate(); delay(0.30); } else { dbg('no-focus mode: skipping activate()'); }

  var proc = se.processes.byName(zoom);
  var wins = proc.windows();
  dbg('windows=' + wins.length);
  for (var i=0;i<wins.length;i++){
    var nm=''; try{ nm = wins[i].name() || ''; }catch(e){}
    dbg('window['+i+']="'+nm+'"');
  }
  if (wins.length===0) return 'NO_WINDOWS';

  var PREFERRED = PANE; // "Transcript"
  var scope = null;

  // 2) scope: prefer undocked Transcript window
  for (var i=0;i<wins.length;i++){
    var nm=''; try{ nm = wins[i].name() || ''; }catch(e){}
    if (nm === PREFERRED){ scope = wins[i]; dbg('scope=Transcript window (undocked)'); break; }
  }
  // 3) else "Zoom Meeting"
  if (!scope){
    for (var i=0;i<wins.length;i++){
      var nm=''; try{ nm = wins[i].name() || ''; }catch(e){}
      if (/meeting/i.test(nm)){ scope = wins[i]; dbg('scope=Zoom Meeting window'); break; }
    }
  }
  // 4) else first named window, else last window
  if (!scope){
    for (var i=0;i<wins.length;i++){
      var nm=''; try{ nm = wins[i].name() || ''; }catch(e){}
      if (nm){ scope = wins[i]; dbg('scope=first named window "'+nm+'"'); break; }
    }
  }
  if (!scope){ scope = wins[wins.length-1]; dbg('scope=last window (fallback)'); }

  // helper: press with AXPress or click()
  function press(el){
    try { el.actions.byName('AXPress').perform(); return true; } catch(e){}
    try { el.click(); return true; } catch(e){}
    return false;
  }

  // 5) search: label match first, then last button in scope
  function searchAndPress(scopeObj, label){
    try {
      // Try to get elements more efficiently - start with direct children
      var elems = null;
      try {
        // First try a more targeted approach: get UI elements directly
        var uiElems = scopeObj.UIElements();
        if (uiElems && uiElems.length > 0) {
          // Build a smaller list from direct UI elements and their children
          elems = [];
          for (var k=0; k<uiElems.length && k<50; k++) { // Limit to first 50 to avoid hanging
            try {
              elems.push(uiElems[k]);
              var children = uiElems[k].UIElements();
              if (children) {
                for (var c=0; c<children.length && c<20; c++) {
                  elems.push(children[c]);
                }
              }
            } catch(_){}
          }
          dbg('using targeted UI elements scan: ' + elems.length);
        }
      } catch(_){}
      
      // Fallback to entireContents if targeted approach didn't work
      if (!elems || elems.length === 0) {
        try {
          elems = scopeObj.entireContents();
          dbg('using entireContents scan: ' + elems.length);
        } catch(e) {
          dbg('entireContents() failed: ' + e);
          return 'NOT_FOUND';
        }
      }
      
      if (!elems || elems.length === 0) {
        dbg('no elements found in scope');
        return 'NOT_FOUND';
      }

      // 5a) match by name/description/help
      for (var i=0;i<elems.length;i++){
        var e = elems[i];
        try{
          var nm = (e.name && e.name()) || '';
          var d  = (e.description && e.description()) || '';
          var h  = (e.help && e.help()) || '';
          var hay = (nm + '|' + d + '|' + h).toLowerCase();
          if (hay.indexOf(label) !== -1){
            dbg('MATCH label nm="'+nm+'" d="'+d+'" h="'+h+'"');
            if (press(e)){ dbg('ACTION: press by label -> OK'); return 'OK_LABEL'; }
            dbg('press failed on label match; continuing');
          }
        }catch(_){}
      }

      // 5b) fallback: last button
      var btns = [];
      for (var j=0;j<elems.length;j++){
        var ee = elems[j];
        try{
          var role = (ee.role && ee.role()) || '';
          if (role.toLowerCase() === 'button'){
            if (DEBUG && btns.length < 5){
              var nm2=(ee.name&&ee.name())||'', d2=(ee.description&&ee.description())||'', h2=(ee.help&&ee.help())||'';
              dbg('button['+btns.length+'] name="'+nm2+'" desc="'+d2+'" help="'+h2+'"');
            }
            btns.push(ee);
          }
        }catch(_){}
      }
      dbg('AXButtons in scope=' + btns.length);
      if (btns.length>0){
        var last = btns[btns.length-1];
        var nml=(last.name&&last.name())||'', des=(last.description&&last.description())||'', hlp=(last.help&&last.help())||'';
        dbg('lastBtn name="'+nml+'" desc="'+des+'" help="'+hlp+'"');
        if (press(last)){ dbg('ACTION: press lastBtn -> OK'); return 'OK_FALLBACK'; }
        return 'PRESS_FAILED';
      }
    }catch(e){ dbg('entireContents() failed on scope: ' + e); }
    return 'NOT_FOUND';
  }

  var status = searchAndPress(scope, NEEDLE);
  return status;
})();
"""


def run_jxa(
    text: str, pane: str, app: str | None, debug: bool, do_act: bool, timeout: int = 10
) -> str:
    candidates = [app] if app else ["zoom.us", "Zoom Workplace"]
    jxa = (
        JXA_TEMPLATE.replace("__DEBUG__", "true" if debug else "false")
        .replace("__PANE__", json.dumps(pane))
        .replace("__NEEDLE__", json.dumps(text.lower()))
        .replace("__CANDIDATES__", json.dumps(candidates))
        .replace("__DO_ACT__", "true" if do_act else "false")
    )
    try:
        proc = subprocess.run(
            ["osascript", "-l", "JavaScript", "-"],
            input=jxa,
            text=True,
            capture_output=True,
            timeout=timeout,
        )
        out = (proc.stdout or "") + (proc.stderr or "")
        return out.strip()
    except subprocess.TimeoutExpired:
        return "TIMEOUT"
    except Exception as e:
        return f"ERROR: {str(e)}"


def main():
    ap = argparse.ArgumentParser(
        description="Zoom Transcript autoclicker (no mouse). Prefers background (no focus), falls back to focus."
    )
    ap.add_argument(
        "--text",
        default="save transcript",
        help="Substring to match in name/description/help (case-insensitive). Default: 'save transcript'",
    )
    ap.add_argument(
        "--pane",
        default="Transcript",
        help="Pane/window label to anchor scope. Default: Transcript",
    )
    ap.add_argument(
        "--app",
        default=None,
        help="Override Zoom process name (e.g., 'zoom.us' or 'Zoom Workplace').",
    )
    ap.add_argument(
        "--interval", type=int, default=60, help="Seconds between clicks. Default: 60"
    )
    ap.add_argument(
        "--timeout",
        type=int,
        default=10,
        help="Timeout in seconds for each osascript call. Default: 10",
    )
    ap.add_argument("--once", action="store_true", help="Click once then exit.")
    ap.add_argument(
        "--debug", action="store_true", help="Print detailed [DBG] logs from JXA."
    )
    mode = ap.add_mutually_exclusive_group()
    mode.add_argument(
        "--background-only",
        action="store_true",
        help="Never focus Zoom; do not fall back to focus.",
    )
    mode.add_argument(
        "--force-focus",
        action="store_true",
        help="Always focus Zoom before scanning; skip background attempt.",
    )
    args = ap.parse_args()

    if shutil.which("osascript") is None:
        print("[ERROR] macOS 'osascript' not found.", file=sys.stderr)
        sys.exit(1)

    print(f"[RUN] Python: {sys.executable}")
    print(f"[RUN] Zoom app candidates: {args.app or 'zoom.us, Zoom Workplace'}")
    print(f"[RUN] Target text: {args.text!r} | Pane: {args.pane!r}")
    pref = (
        "background-only"
        if args.background_only
        else (
            "force-focus" if args.force_focus else "auto (background → focus fallback)"
        )
    )
    print(f"[RUN] Mode: {pref} | Interval: {args.interval}s | Debug: {args.debug}")
    print(
        "[NOTE] Ensure Accessibility + Automation permissions for your terminal, Python, System Events, and Zoom."
    )

    def print_result(tag: str, out: str):
        if args.debug:
            print(f"[{tag}] {out}")
            if out:
                print("[STATUS]", out.splitlines()[-1])
        else:
            status = out.splitlines()[-1] if out else ""
            print(f"[{tag}] {status or '[NO OUTPUT]'}")

    try:
        while True:
            if args.interval > 0 and not args.once:
                time.sleep(args.interval)

            if args.force_focus:
                # Always focus
                out = run_jxa(
                    args.text,
                    args.pane,
                    args.app,
                    args.debug,
                    do_act=True,
                    timeout=args.timeout,
                )
                print_result("FOCUS", out)

            elif args.background_only:
                # Never focus
                out = run_jxa(
                    args.text,
                    args.pane,
                    args.app,
                    args.debug,
                    do_act=False,
                    timeout=args.timeout,
                )
                print_result("BG", out)

            else:
                # AUTO: try background first, then fallback to focus if needed
                out_bg = run_jxa(
                    args.text,
                    args.pane,
                    args.app,
                    args.debug,
                    do_act=False,
                    timeout=args.timeout,
                )
                status_bg = out_bg.splitlines()[-1] if out_bg else ""
                if status_bg in ("OK_LABEL", "OK_FALLBACK"):
                    print_result("BG", out_bg)
                elif status_bg == "TIMEOUT":
                    # If background times out, try focus mode as fallback
                    if args.debug:
                        print_result("BG", out_bg)
                    out_fg = run_jxa(
                        args.text,
                        args.pane,
                        args.app,
                        args.debug,
                        do_act=True,
                        timeout=args.timeout,
                    )
                    print_result("FOCUS", out_fg)
                else:
                    # Fallback with a quick focus hop
                    out_fg = run_jxa(
                        args.text,
                        args.pane,
                        args.app,
                        args.debug,
                        do_act=True,
                        timeout=args.timeout,
                    )
                    # Print both results so it's clear what happened
                    if args.debug:
                        print_result("BG", out_bg)
                        print_result("FOCUS", out_fg)
                    else:
                        # If focus succeeded, show FOCUS; otherwise show BG status
                        status_fg = out_fg.splitlines()[-1] if out_fg else ""
                        which = (
                            "FOCUS"
                            if status_fg in ("OK_LABEL", "OK_FALLBACK")
                            else "BG"
                        )
                        print_result(which, out_fg if which == "FOCUS" else out_bg)

            if args.once:
                break
    except KeyboardInterrupt:
        print("\n[STOP] User interrupted.")


if __name__ == "__main__":
    main()
